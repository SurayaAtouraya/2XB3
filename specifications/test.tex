\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{Group Project, Specification}
\author{SFWR ENG 2XB3 - Group 14}

\begin {document}

\maketitle

The purpose of this document is to  povide a description of the classes/modules we have decided to use in our application, and explain why we have decomposed the application into these classes. We have included a UML class diagram showing a static representation of our application classes and the relationship between classes.

Also, for each class, a description of the interface (public entities) as well as a description of the syntax is provided.


\newpage

\section* {Contractor Module}

\subsection*{Template Module}

Contractor

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

Contractor = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
$Contractor$ & $String$, $String$, $String$,$String$,$String$,$String$,$String$,$String$,$String$,$\mathbb{Z}$  & $Contractor$ & \\
\hline
$Contractor$ & $String$, $String$, $String$ & $Contractor$ & ~\\
\hline
isActive & ~ & $\mathbb{B}$ & ~\\
\hline
getLicenseNumber & ~ &  $\mathbb{Z}$ &
\\
\hline
getAddress & ~ & $String$ & \\
\hline
getContractorName & ~ & $String$ & \\
\hline 
getCity & ~ & $String$ & \\
\hline 
getState & ~ & $String$ & \\
\hline 
getSpecialty & ~ & $String$ & \\
\hline 
CompareTo & $Contractor$ & $\mathbb{Z}$ & \\
\hline 
avgReview & $Map$ & $String$ & \\
\hline 
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

businessName: $String$\\
licenseNumber: $String$\\
address: $String$\\
city: $String$\\
state: $String$\\
zip: $String$\\
number: $String$\\
specialty: $String$\\
contractorName: $String$\\
activeLicense: $\mathbb{Z}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

The constructor Contractor is called for each object instance before any other
access routine is called for that object.  The constructor cannot be called on
an existing object.

\subsubsection* {Access Routine Semantics}

Contractor($Name,License,address,city,state,zip,number,specialty, contractorName, acLicense$):
\begin{itemize}
\item transition: $ businessName, licenseNumber, address, city, state, zip, number, specialty, contractorName, activeLicense:= Name,License,address,city,state,zip,number,specialty, contractorName,acLicense$
\item output: $out := \mathit{self}$
\item exception: None
\end{itemize}

\noindent contractor(city1,state1,specialty1):
\begin{itemize}
\item transition: $city, state, specialty := city1, state1, specialty1$
\item exception: None
\end{itemize}

\noindent isActive():
\begin{itemize}
\item output: $out := (activeLicense = 1) \Rightarrow True | False$
\end{itemize}

\noindent getLicenseNumber():
\begin{itemize}
\item output: $out := licenseNumber$
\end{itemize}


\noindent getAddress():
\begin{itemize}
\item output: $out := address$
\end{itemize}

\noindent getContractorName():
\begin{itemize}
\item output: $out := businessName$
\end{itemize}

\noindent getCity():
\begin{itemize}
\item output: $out := city$
\end{itemize}

\noindent getState():
\begin{itemize}
\item output: $out := state$
\end{itemize}

\noindent getSpecialty():
\begin{itemize}
\item output: $out := specialty$
\end{itemize} 

\noindent compareTo(that):
\begin{itemize}
\item output: $out := \neg (self.getActive() = that.getActive()) \Rightarrow ((self.getActive() = True) \Rightarrow 1 | False) $ 
\end{itemize} 

\noindent avgReview(map):
\begin{itemize}
\item output: $out := \neg (self.getActive() = that.getActive()) \Rightarrow ((self.getActive() = True) \Rightarrow 1 | False) $ 
\end{itemize} 


\newpage

\section* {Search Module}

\subsection*{Template Module}

Search

\subsection* {Uses}

Contractor
DataReader
Reviews

\subsection* {Syntax}

\subsubsection* {Exported Types}

N/A

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
search & seq of Contractor, Contractor, String & seq of Contractor & IOException\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

N/A

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

N/A

\subsubsection* {Access Routine Semantics}

search(Contractors,Contractor,filename):
\begin{itemize}
\item output: out := $\{c : Contractor | c \in Contractors : \\ ((c.getCity() = Contractor.getCity()) \wedge (c.getState() = Contractor.getState()) \wedge (c.getSpecialty() = Contractor.getSpecialty()) | c.getSpecialty() = General) \Rightarrow c \}$
\item exception: None
\end{itemize}


\newpage

\section* {Sort Module}

\subsection*{Template Module}

Sort

\subsection* {Uses}

Contractor
DataReader
Reviews

\subsection* {Syntax}

\subsubsection* {Exported Types}

N/A

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
sort & seq of Contractor &  & \\
\hline
isSorted & seq of Contractor & $\mathbb{B}$ & \\
\hline

\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

N/A

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

N/A

\subsubsection* {Access Routine Semantics}

isSorted(Contractors):
\begin{itemize}
\item output: out := $\forall (i : \mathbb{N} | i \in [0..|Contractors|-2] : (Contractors[i].compareTo(Contractors[i+1]) <= 0)$
\item exception: None
\end{itemize}

sort(Contractors):
\begin{itemize}
\item output: out := $Contractor^n$ such that $\forall(c : Contractor | c \in Contractors : \exists(b : Contractor | b \in B : b.compareTo(c) = 0 \wedge count(c,Contractors) = count(b,B))) \wedge isSorted(B)$
\item exception: None
\end{itemize}

\subsubsection* {Local Funtions}

$count(a,A) : Contractor \times Contractor^n$ \\
$count(a,A) \equiv +(i : \mathbb{N} | i \in [0..|A|-1] \wedge A[i].compareTo(a) = 0 : 1)$ \\


\end {document}\grid
