\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{Group Project, Specification}
\author{SFWR ENG 2XB3 - Group 14}

\begin {document}

\maketitle

The purpose of this document is to  povide a description of the classes/modules we have decided to use in our application, and explain why we have decomposed the application into these classes. We have included a UML class diagram showing a static representation of our application classes and the relationship between classes.

Also, for each class, a description of the interface (public entities) as well as a description of the syntax is provided.


\newpage

\section* {Line ADT Module}

\subsection*{Template Module}

LineT

\subsection* {Uses}

\wss{What should go here?}PointT, MapTypes

\subsection* {Syntax}

\subsubsection* {Exported Types}

LineT = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
LineT & PointT, CompassT, $\mathbb{N}$ & LineT & invalid\_argument\\
\hline
strt & ~ & PointT & ~\\
\hline
end & ~ & PointT & ~\\
\hline
orient & ~ & CompassT & ~\\
\hline
 len & ~ & $\mathbb{N}$ & ~\\
\hline
flip & ~ & LineT & ~\\
\hline
rotate & RotateT & LineT & ~\\
\hline
translate & $\mathbb{Z}$, $\mathbb{Z}$ & LineT  & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$s$: PointT\\
$o$: CompassT\\
$L$: $\mathbb{N}$\\ 

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

The constructor LineT is called for each object instance before any other
access routine is called for that object.  The constructor cannot be called on
an existing object.

\subsubsection* {Access Routine Semantics}

LineT($st, ornt, l$):
\begin{itemize}
\item transition: $s, o, L := st, ornt, l$
\item output: $out := \mathit{self}$
\item exception: \wss{Write the spec for an exception when the length of the line is 0}$exc := (L = 0 \Rightarrow \mathrm{invalid\_argument})$
\end{itemize}

\noindent strt():
\begin{itemize}
\item output: $out := \mbox{PointT}(s.x(), s.y())$
\item exception: None
\end{itemize}

\noindent end():
\begin{itemize}
% \item output:
%   $out := (o = \mbox{N} \Rightarrow \mbox{PointT}(s.x, s.y + (L-1)) | o = \mbox{S} \Rightarrow
%   \mbox{PointT}(s.x, s.y - (L-1)) | o = \mbox{W} \Rightarrow \mbox{PointT}(s.x - (L-1), s.y) |
%   o = \mbox{E} \Rightarrow \mbox{PointT}(s.x + (L-1), s.y))$
\item output: \wss{Write the spec for returning the end point of the
    line.}$out := \mbox{PointT}((o = \mbox{W} \Rightarrow s.x - (L-1) | o =
  \mbox{E} \Rightarrow s.x + (L-1) | \mbox{True} \Rightarrow s.x), (o = \mbox{N}
  \Rightarrow s.y + (L-1) | o = \mbox{S} \Rightarrow s.y - (L-1) | \mbox{True}
  \Rightarrow s.y))$

\item exception: None
\end{itemize}

\noindent orient():
\begin{itemize}
\item output: $out := o$
\item exception: None
\end{itemize}

\noindent len():
\begin{itemize}
\item output: $out := L$
\item exception: None
\end{itemize}

\noindent flip():
\begin{itemize}
\item output: \wss{Write the spec for returning a new line that is the mirror
    image of the current line.  That is, the start point and length of the new
    line will remain the same, but the orientation will be changed by 180
    degrees}$out := \mbox{LineT}(s, (o = \mbox{N} \Rightarrow \mbox{S} | o =
  \mbox{S} \Rightarrow \mbox{N} | o = \mbox{W} \Rightarrow \mbox{E} | o =
  \mbox{E} \Rightarrow \mbox{W}), L)$
\item exception: None
\end{itemize}

\noindent rotate(r):
\begin{itemize}
\item output: 
\begin{tabular}{|p{2.cm}|p{2.3cm}|l|}
\hhline{~|~|-|}
\multicolumn{1}{r}{} & \multicolumn{1}{r|}{} & \multicolumn{1}{l|}{$out :=$}\\
\hhline{|-|-|-|}
$r = \mbox{CW}$ & $o = \mbox{N}$ & \wss{?}$\mbox{LineT}(s, E, L)$\\
\hhline{|~|-|-|}
~ & $o = \mbox{S}$ & \wss{?}$\mbox{LineT}(s, W, L)$\\
\hhline{|~|-|-|}
~ & $o = \mbox{W}$ & \wss{?}$\mbox{LineT}(s, N, L)$\\
\hhline{|~|-|-|}
~ & $o = \mbox{E}$ & \wss{?}$\mbox{LineT}(s, S, L)$\\
\hhline{-|-|-|}
$r = \mbox{CCW}$ & $o = \mbox{N}$ & \wss{?}$\mbox{LineT}(s, W, L)$\\
\hhline{|~|-|-|}
~ & $o = \mbox{S}$ & \wss{?}$\mbox{LineT}(s, E, L)$\\
\hhline{|~|-|-|}
~ & $o = \mbox{W}$ & \wss{?}$\mbox{LineT}(s, S, L)$\\
\hhline{|~|-|-|}
~ & $o = \mbox{E}$ & \wss{?}$\mbox{LineT}(s, N, L)$\\
\hhline{-|-|-|}
\end{tabular}

\item exception: None
\end{itemize}

\noindent translate($\Delta x$, $\Delta y$):
\begin{itemize}
\item output: \wss{Add the missing spec}$out := \mbox{LineT}(s.\mbox{translate}(\Delta x, \Delta y), o, L)$
\item exception: None
\end{itemize}

\newpage

\section* {Path ADT Module}

\subsection*{Template Module}

PathT

\subsection* {Uses}

PointT, LineT, MapTypes

\subsection* {Syntax}

\subsubsection* {Exported Types}

PathT = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
PathT & PointT, CompassT, $\mathbb{N}$ & PathT & \\ %LineT constructor for invalid\_argument
\hline
append & CompassT, $\mathbb{N}$ & & invalid\_argument\\ 
\hline
strt & ~ & PointT & ~\\
\hline
end & ~ & PointT & ~\\
\hline
line & $\mathbb{N}$ & LineT & outside\_bounds\\
\hline
size & ~ & $\mathbb{N}$ & \\
\hline
 len & ~ & $\mathbb{N}$ & ~\\
\hline
translate & $\mathbb{Z}$, $\mathbb{Z}$ & PathT  & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$s$: sequence of LineT

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

\begin{itemize}
\item The constructor PathT is called for each object instance before any other
access routine is called for that object.  The constructor cannot be called on
an existing object.
%\item Appends will not be made while iterating through the list of lines.
\end{itemize}

\subsubsection* {Access Routine Semantics}

PathT($st, ornt, l$):
\begin{itemize}
\item transition: \wss{What is the spec to add the first element to the sequence
  of LineT?}$s[0] := \mbox{LineT}(st, ornt, l)$
\item output: $out := \mathit{self}$
\item exception: None
\end{itemize}

\noindent append($ornt, l$):
\begin{itemize}
\item transition: \wss{What is the missing specification?  The appended line
    starts at a point adjacent to the end point of the previous line in the
    direction $ornt$.  The lines are not allowed to
    overlap.}$s := s || \langle \mbox{LineT}(\mbox{adjPt}(ornt), ornt, l\rangle$
\item exception: \wss{What is the specification for the exception?  An exception
    should be generated if the introduced line overlaps with any of the previous
    points in the existing path.}
\begin{multline*}
  exc :=\\
  (\mbox{pointsInLine}(\mbox{LineT}(\mbox{adjPt}(ornt), ornt, l))~\cap~\\ (\cup
  (l: \mbox{LineT} | l \in s : \mbox{pointsInLine}(l))) \neq \emptyset \Rightarrow \mbox{invalid\_argument})
\end{multline*}
\end{itemize}

\noindent strt():
\begin{itemize}
\item output: \wss{What is the missing spec?}$out := s[0].\mbox{strt}$
\item exception: None
\end{itemize}

\noindent end():
\begin{itemize}
\item output: \wss{What is the missing spec?}$out := s[|s|-1].\mbox{end}$
\item exception: None
\end{itemize}

\noindent line($i$):
\begin{itemize}
\item output: \wss{Returns the ith line in the sequence.  What is the missing spec?}$out := \mbox{LineT}(s[i].\mbox{strt}(), s[i].\mbox{orient}(), s[i].\mbox{len}())$
\item exception: \wss{Generate the exception if the index is not in the sequence.}$exc := (i \geq |s| \Rightarrow \mbox{outside\_bounds})$
\end{itemize}

\noindent size:
\begin{itemize}
\item output: \wss{Output the number of lines in the path.}$out := |s|$
\item exception: None
\end{itemize}

\noindent len:
\begin{itemize}
\item output: \wss{Output the total number of points (grid cells) on the path,
    including the beginning and end points (cells).}$out := +(l: \mbox{LineT} | l \in s: l.\mbox{len})$
\item exception: None
\end{itemize}

\noindent translate($\Delta x$, $\Delta y$):
\begin{itemize}
\item output: Create a new PathT object with state variable $s'$ such that:
$$\forall(i: \mathbb{N} | i \in [0..|s|-1] : s'[i] = s[i].\mbox{translate}(\Delta x, \Delta y))$$
\item exception: None
\end{itemize}

\subsection*{Local Functions}

pointsInLine: $\mbox{LineT} \rightarrow \mbox{(set of PointT)}$\\

\noindent pointsInLine ($l$) 
\begin{multline*}
\equiv \{ i: \mathbb{N} | i \in [0
  .. (l.\mbox{len} - 1)] : l.\mbox{strt}.\mbox{translate}(\wss{Complete the spec.}\\
(l.\mbox{orient}=\mbox{W} \Rightarrow -i |
  l.\mbox{orient}=\mbox{E} \Rightarrow i | \mbox{True} \Rightarrow 0), (l.\mbox{orient}=\mbox{N} \Rightarrow i |
  l.\mbox{orient}=\mbox{S} \Rightarrow -i | \mbox{True} \Rightarrow 0) ) \}
\end{multline*}

\noindent adjPt: $\mbox{CompassT} \rightarrow \mbox{PointT}$\\
adjPt$(ornt) \equiv$

\medskip

\begin{tabular}{|l|l|}
\hline
$ornt = \mbox{N}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{?}(0, 1)$\\
\hline
$ornt = \mbox{S}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{?}(0, -1)$\\
\hline
$ornt = \mbox{W}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{?}(-1, 0)$\\
\hline
$ornt = \mbox{E}$ & $s[|s|-1].\mbox{end}.\mbox{translate}\wss{?}(1, 0)$\\
\hline
\end{tabular}

\newpage

\section* {Generic Seq2D Module}

\subsection* {Generic Template Module}

Seq2D(T)

\subsection* {Uses}

MapTypes, PointT, LineT, PathT

\subsection* {Syntax}

\subsubsection* {Exported Types}

Seq2D(T) = ?

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Seq2D & seq of (seq of T), $\mathbb{R}$ & Seq2D & invalid\_argument\\
\hline
set & PointT, T & ~ & outside\_bounds\\
\hline
get & PointT & T & outside\_bounds\\
\hline
getNumRow & ~ & $\mathbb{N}$ & \\
\hline
getNumCol & ~ & $\mathbb{N}$ & \\
\hline
getScale & ~ & $\mathbb{R}$ & \\
\hline
count & T & $\mathbb{N}$ & \\
\hline
count & LineT, T & $\mathbb{N}$ & invalid\_argument\\
\hline
count & PathT, T & $\mathbb{N}$ & invalid\_argument\\
\hline
length & PathT & $\mathbb{R}$ & invalid\_argument\\
\hline
connected & PointT, PointT & $\mathbb{B}$ & invalid\_argument\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$s$: seq of (seq of T)\\
scale: $\mathbb{R}$\\
nRow: $\mathbb{N}$\\
nCol: $\mathbb{N}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

\begin{itemize}
\item The Seq2D(T) constructor is called for each object instance before any
other access routine is called for that object.  The constructor can only be
called once.
\item Assume that the input to the constructor is a sequence of rows, where each
  row is a sequence of elements of type T.  The number of columns (number of
  elements) in each row is assumed to be equal. That is each row
  of the grid has the same number of entries.  $s[i][j]$ means the ith row and
  the jth column.  The 0th row is at the bottom of the map and the 0th column
  is at the leftmost side of the map.
\end{itemize}

\subsubsection* {Access Routine Semantics}

Seq2D($S$, scl):
\begin{itemize}
\item transition: \wss{Fill in the transition.}$s, \mbox{scale}, \mbox{nCol}, \mbox{nRow} := S,
  \mbox{scl}, |S[0]|, |S|$
\item output: $\mathit{out} := \mathit{self}$
\item exception: \wss{Fill in the exception.  One should be generated if the
    scale is less than zero, or the input sequence is empty, or the number of
    columns is zero in the first row, or the number of columns in any row is
    different from the number of columns in the first row.}$exc := (\mbox{scale} \leq 0 \lor |S| = 0 \lor |S[0]| = 0 \Rightarrow \mbox{invalid\_argument}|\\
  \lnot\forall(l : \mbox{seq of T}|l \in S : |l| = |S[0]|) \Rightarrow
  \mbox{invalid\_argument})$
\end{itemize}

\noindent set($p, v$):
\begin{itemize}
\item transition: \wss{?}$s[p.y][p.x] := v$
\item exception: \wss{Generate an exception if the point lies outside of the
    map.}$exc := (\neg \mbox{validPoint}(p) \Rightarrow \mbox{outside\_bounds})$
\end{itemize}

\noindent get($p$):
\begin{itemize}
\item output: \wss{?}$out := s[p.y][p.x]$
\item exception: \wss{Generate an exception if the point lies outside of the
    map.}$exc := (\neg \mbox{validPoint}(p) \Rightarrow \mbox{outside\_bounds})$
\end{itemize}

\noindent getNumRow():
\begin{itemize}
\item output: $out := \mbox{nRow}$
\item exception: None
\end{itemize}

\noindent getNumCol():
\begin{itemize}
\item output: $out := \mbox{nCol}$
\item exception: None
\end{itemize}

\noindent getScale():
\begin{itemize}
\item output: $out := \mbox{scale}$
\item exception: None
\end{itemize}

\noindent count($t$: T):
\begin{itemize}
\item output: \wss{Count the number of times the value $t$ occurs in the 2D
    sequence.}$out := +(i, j: \mathbb{N}| \mbox{validRow}(i) \land
  \mbox{validCol}(j) \wedge s[i][j] = t : 1)$
\item exception: None
\end{itemize}

\noindent count($l$: LineT, $t$: T):
\begin{itemize}
\item output: \wss{Count the number of times the value $t$ occurs in the line
    $l$.}$out := +(p: \mbox{PointT} | p \in \mbox{pointsInLine}(l) \wedge
  s[p.y][p.x] = t : 1)$
\item exception: \wss{Exception if any point on the line lies off of the 2D
    sequence (map)}$exc := (\neg\mbox{validLine}(l) \Rightarrow \mbox{invalid\_argument})$
\end{itemize}

\noindent count($\mathit{pth}$: PathT, $t$: T):
\begin{itemize}
\item output: \wss{Count the number of times the value $t$ occurs in the path
    $pth$.}$out := +(p: \mbox{PointT} | p \in \mbox{pointsInPath}(\mathit{pth})
  \wedge s[p.y][p.x] = t : 1)$
\item exception: \wss{Exception if any point on the path lies off of the 2D
    sequence (map)}$exc := (\neg\mbox{validPath}(\mathit{pth}) \Rightarrow \mbox{invalid\_argument})$
\end{itemize}

\noindent length($\mathit{pth}$: PathT):
\begin{itemize}
\item output: \wss{Use the scale to find the length of the
    path.}$out := \mathit{pth}.\mbox{len} \cdot \mbox{scale}$
\item exception: \wss{Exception if any point on the path lies off of the 2D
    sequence (map)}$exc := (\neg\mbox{validPath}(\mathit{pth}) \Rightarrow \mbox{invalid\_argument})$
\end{itemize}

\noindent connected($p_1$: PointT, $p_2$: PointT):
\begin{itemize}
\item output: \wss{Return true if a path exists between $p_1$ and $p_2$ with all
    of the points on the path being of the same value.  $p_1$ and $p_2$ are
    considered to be part of the path.}
  $out := \exists (\mathit{pth}: \mbox{PathT} | \mbox{validPath}(\mathit{pth})
  \wedge \mathit{pth}.\mbox{strt} = p_1 \wedge \mathit{pth}.\mbox{end} = p_2 :
  \mbox{count}(\mathit{pth}, s[p_1.y][p_1.x]) = \mathit{pth}.\mbox{len})$
\item exception: \wss{Return an exception if either of the input points is not
    valid.}$exc := (\neg\mbox{validPoint}(p_1) \vee \neg\mbox{validPoint}(p_1)
  \Rightarrow \mbox{invalid\_argument})$

\end{itemize}

\subsection*{Local Functions}

\noindent validRow: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{returns true if the given natural number is a valid row
  number.}$\mbox{validRow}(i) \equiv 0 \leq i \leq (\mbox{nRow} - 1)$\\

\noindent validCol: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{returns true if the given natural number is a valid column
  number.}$\mbox{validCol}(j) \equiv 0 \leq j \leq (\mbox{nCol} - 1)$\\

\noindent validPoint: $\mbox{PointT} \rightarrow \mathbb{B}$\\
\noindent \wss{Returns true if the given point lies within the boundaries of the
  map.}$\mbox{validPoint}(p) \equiv \mbox{validRow}(p.y) \wedge \mbox{validCol}(p.x)$\\

\noindent validLine: $\mbox{LineT} \rightarrow \mathbb{B}$\\
\noindent \wss{Returns true if all of the points for the given line lie within the boundaries of the
  map.}$\mbox{validLine}(l) \equiv \forall(p: \mbox{PointT} | p \in \mbox{pointsInLine}(l):
  \mbox{validPoint}(p))$\\

\noindent validPath: $\mbox{PathT} \rightarrow \mathbb{B}$\\
\noindent \wss{Returns true if all of the points for the given path lie within the boundaries of the
  map.}$\mbox{validPath}(\mathit{pth}) \equiv \forall(p: \mbox{PointT} | p \in \mbox{pointsInPath}(\mathit{pth}):
  \mbox{validPoint}(p))$\\

\noindent pointsInLine: $\mbox{LineT} \rightarrow \mbox{(set of PointT)}$\\
\noindent pointsInLine ($l$) 
\wss{The same local function as given in the Path module.}
\begin{multline*}
\equiv \{ i: \mathbb{N} | i \in [0
  .. (l.\mbox{len} - 1)] : l.\mbox{strt}.\mbox{translate}(\\
(l.\mbox{orient}=\mbox{W} \Rightarrow -i |
  l.\mbox{orient}=\mbox{E} \Rightarrow i | \mbox{True} \Rightarrow 0), (l.\mbox{orient}=\mbox{N} \Rightarrow i |
  l.\mbox{orient}=\mbox{S} \Rightarrow -i | \mbox{True} \Rightarrow 0) ) \}
\end{multline*}

\noindent pointsInPath: $\mbox{PathT} \rightarrow \mbox{(set of PointT)}$\\
\wss{Return the set of points that make up the input path.}
\noindent pointsInPath($p$) 
$\equiv \cup (i: \mathbb{N} | i \in [0..p.\mbox{size}]:
\mbox{pointsInLine}(p.\mbox{line}(i)))$

\newpage

\section* {LanduseMap Module}

\subsection* {Template Module}

LanduseMapT is Seq2D(LanduseT)

\section* {DEM Module}

\subsection* {Template Module}

DEMT is Seq2D($\mathbb{Z}$)

\newpage

\section{Critique of Design}

Write a critique of the interface for the modules in this project.  Is there
anything missing?  Is there anything you would consider changing?  Why?

\end {document}